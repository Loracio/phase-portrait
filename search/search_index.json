{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What's this? The idea behind this project was to create a simple way to make phase portraits in 2D and 3D, as we couldn't find something similar on the internet, so we got down to work. Eventually, we did some work on bifurcations, 1D maps and chaos. This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming. We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome! At first, this project was made up in spanish. The spanish version can be found here . Authors V\u00edctor Loras Herrero (vhloras@gmail.com) Unai Ler\u00eda Fortea (unaileria@gmail.com) Installation Installation via pip: $ pip install phaseportrait Installation via git: Open a terminal on desired route and type the following $ git clone https://github.com/Loracio/phase-portrait Manual installation Visit phase-portrait webpage on GitHub. Click on green button saying Code , and download it in zip format. Save and unzip on desired directory. Examples of use examples.ipynb : Examples showing how to use PhasePortrait2D class. sliderExamples.py : Examples using the slider feature from PhasePortrait2D class. TrajectoryExamples.py : Contains examples of 2D and 3D trajectories with and without sliders.","title":"Home"},{"location":"#whats-this","text":"The idea behind this project was to create a simple way to make phase portraits in 2D and 3D, as we couldn't find something similar on the internet, so we got down to work. Eventually, we did some work on bifurcations, 1D maps and chaos. This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming. We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome! At first, this project was made up in spanish. The spanish version can be found here .","title":"What's this?"},{"location":"#authors","text":"V\u00edctor Loras Herrero (vhloras@gmail.com) Unai Ler\u00eda Fortea (unaileria@gmail.com)","title":"Authors"},{"location":"#installation","text":"Installation via pip: $ pip install phaseportrait Installation via git: Open a terminal on desired route and type the following $ git clone https://github.com/Loracio/phase-portrait Manual installation Visit phase-portrait webpage on GitHub. Click on green button saying Code , and download it in zip format. Save and unzip on desired directory.","title":"Installation"},{"location":"#examples-of-use","text":"examples.ipynb : Examples showing how to use PhasePortrait2D class. sliderExamples.py : Examples using the slider feature from PhasePortrait2D class. TrajectoryExamples.py : Contains examples of 2D and 3D trajectories with and without sliders.","title":"Examples of use"},{"location":"contributing/","text":"Contributing The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered: Fork the project, add a new feature / improve the existing ones and pull a request via GitHub. Contact us on our emails: vhloras@gmail.com unaileria@gmail.com","title":"Contributing"},{"location":"contributing/#contributing","text":"The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered: Fork the project, add a new feature / improve the existing ones and pull a request via GitHub. Contact us on our emails: vhloras@gmail.com unaileria@gmail.com","title":"Contributing"},{"location":"dFfunction/","text":"dF function This function is thought to compute the derivatives of given coordinates: def dF(x,y): return expressionX , expressionY It must contain as much args as returned elements. kargs Kargs can be given. They can be changed using sliders method. For an harmonic oscillator, the dF function will be defined as: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x Where \u03c9 is the angular frequency of the oscillator. General definiton In general, dF function will be defined the following way: def dF(*args, *, **kargs) -> tuple: Where: len(dF(*args, **kargs)) == len(args)","title":"dF Function"},{"location":"dFfunction/#df-function","text":"This function is thought to compute the derivatives of given coordinates: def dF(x,y): return expressionX , expressionY It must contain as much args as returned elements.","title":"dF function"},{"location":"dFfunction/#kargs","text":"Kargs can be given. They can be changed using sliders method. For an harmonic oscillator, the dF function will be defined as: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x Where \u03c9 is the angular frequency of the oscillator.","title":"kargs"},{"location":"dFfunction/#general-definiton","text":"In general, dF function will be defined the following way: def dF(*args, *, **kargs) -> tuple: Where: len(dF(*args, **kargs)) == len(args)","title":"General definiton"},{"location":"getting_started/","text":"Instructions Using phaseportrait is easy, it has to be firstly imported, which can be done this way: from phaseportrait import * This will let us use the following classes: PhasePortrait2D Trajectory3D Both of them share their first arg: a function that computes the derivative of given coordinates in a point. dF function def dF(x,y): return expressionX , expressionY Extra variables can also be passed in dictionary form. For example, we can pass \u03c9 parameter for an harmonic oscillator with default value 1 the following way: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x PhasePortrait2D class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args. Trajectory2D class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 2D trajectories given a dF function with 3 args. Trajectory3D class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 3D trajectories given a dF function with 3 args.","title":"Getting started"},{"location":"getting_started/#instructions","text":"Using phaseportrait is easy, it has to be firstly imported, which can be done this way: from phaseportrait import * This will let us use the following classes: PhasePortrait2D Trajectory3D Both of them share their first arg: a function that computes the derivative of given coordinates in a point.","title":"Instructions"},{"location":"getting_started/#df-function","text":"def dF(x,y): return expressionX , expressionY Extra variables can also be passed in dictionary form. For example, we can pass \u03c9 parameter for an harmonic oscillator with default value 1 the following way: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x","title":"dF function"},{"location":"getting_started/#phaseportrait2d","text":"class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args.","title":"PhasePortrait2D"},{"location":"getting_started/#trajectory2d","text":"class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 2D trajectories given a dF function with 3 args.","title":"Trajectory2D"},{"location":"getting_started/#trajectory3d","text":"class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 3D trajectories given a dF function with 3 args.","title":"Trajectory3D"},{"location":"license/","text":"MIT License Copyright (c) 2021 V\u00edctor Loras & Unai Ler\u00eda Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) 2021 V\u00edctor Loras & Unai Ler\u00eda Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"phaseportrait2d/","text":"PhasePortrait2D class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args. Attributes Methods dF add_slider Range plot dF_args Density Polar L Title xlabel ylabel color sliders fig ax Attributes dF ( dF function) - computes the derivatives of given coordinates. dF_args (dict) - dictionary with parameters for dF function. Range (Optional[list, float]) - see defining a 2D range . Polar (bool) - boolean with default value False . It must be passed when dF function computes polar coordinates. Density (float) - controls closeness of nearby trajectories. Default value is 1. Changing this value affects considerably computing time. MeshDim (int) - in order to calculate the phase portrait, a mesh is created, which depends on the given range. The side of the mesh is calculated by multiplying MeshDim value by the length of given Range . Default value is 10. Title (str) - title of the plot. Default value is 'Phase Portrait' . xlabel (str) - x axis label in the plot. Default value is 'X' . ylabel (str) - y axis label in the plot. Default value is r\"$\\dot{X}$\" . Methods PhasePortrait2D .plot PhasePortrait2D . plot (*, color=None) Takes as arguments class attributes. Color scheme can be changed introducing kwarg color . A list with accepted values can be found here . PhasePortrait2D .add_slider PhasePortrait2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Defining Range: A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"PhasePortrait2d"},{"location":"phaseportrait2d/#phaseportrait2d","text":"class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args. Attributes Methods dF add_slider Range plot dF_args Density Polar L Title xlabel ylabel color sliders fig ax","title":"PhasePortrait2D"},{"location":"phaseportrait2d/#attributes","text":"dF ( dF function) - computes the derivatives of given coordinates. dF_args (dict) - dictionary with parameters for dF function. Range (Optional[list, float]) - see defining a 2D range . Polar (bool) - boolean with default value False . It must be passed when dF function computes polar coordinates. Density (float) - controls closeness of nearby trajectories. Default value is 1. Changing this value affects considerably computing time. MeshDim (int) - in order to calculate the phase portrait, a mesh is created, which depends on the given range. The side of the mesh is calculated by multiplying MeshDim value by the length of given Range . Default value is 10. Title (str) - title of the plot. Default value is 'Phase Portrait' . xlabel (str) - x axis label in the plot. Default value is 'X' . ylabel (str) - y axis label in the plot. Default value is r\"$\\dot{X}$\" .","title":"Attributes"},{"location":"phaseportrait2d/#methods","text":"","title":"Methods"},{"location":"phaseportrait2d/#phaseportrait2dplot","text":"PhasePortrait2D . plot (*, color=None) Takes as arguments class attributes. Color scheme can be changed introducing kwarg color . A list with accepted values can be found here .","title":"PhasePortrait2D.plot"},{"location":"phaseportrait2d/#phaseportrait2dadd_slider","text":"PhasePortrait2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time.","title":"PhasePortrait2D.add_slider"},{"location":"phaseportrait2d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Defining Range:"},{"location":"slider/","text":"Sliders class phaseportrait.sliders. Slider ( portrait, param_name, valinit=None, valstep=0.1, valinterval=[] ) This class is not pretended to be used by the user. It is controlled by the other objects automatically. Adds a slider which can change the value of a parameter in dF during execution time. add_slider method . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Args : * param_name : string type. It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the dF function. **kargs : valinit: initial value of param_name variable. Default value is 0.5 . valstep : slider's step value. Default value is 0.1 . valinterval : slider's range. Default value is [-10, 10] .","title":"Slider"},{"location":"slider/#sliders","text":"class phaseportrait.sliders. Slider ( portrait, param_name, valinit=None, valstep=0.1, valinterval=[] ) This class is not pretended to be used by the user. It is controlled by the other objects automatically. Adds a slider which can change the value of a parameter in dF during execution time.","title":"Sliders"},{"location":"slider/#add_slider","text":"method . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Args : * param_name : string type. It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the dF function. **kargs : valinit: initial value of param_name variable. Default value is 0.5 . valstep : slider's step value. Default value is 0.1 . valinterval : slider's range. Default value is [-10, 10] .","title":"add_slider"},{"location":"trajectory/","text":"trajectory class phaseportrait.trajectories. trajectory ( dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg ) Parent class for trajectories. Represents trajectories given a dF function with N args. Class inheriting must have the following methods: def _prepare_plot(self): ... Prepares the plots: axis titles, graph title, grid, etc. def _plot_lines(self, val, val_init): ... Plots a line of points given in a tuple of positions val and an initial position val_init , both N-dimensional. def _scatter_start_point(self, val_init): ... Marks starting position val_init (N-dimensional) in the several plots created. def _scatter_trajectory(self, val, color, cmap): ... Plots with points val (N-dimensional list) according to color (N-dimensional) with cmap color map. Example (from Trajectories2D): def _plot_lines(self, val, val_init): self.ax['Z'].plot(val[0,1:], val[1,1:], label=f\"({','.join(tuple(map(str, val_init)))})\") def _scatter_start_point(self, val_init): self.ax['Z'].scatter(val_init[0], val_init[1], s=self.size+1, c=[0]) def _scatter_trajectory(self, val, color, cmap): self.ax['Z'].scatter(val[0,:], val[1,:], s=self.size, c=color, cmap=cmap) def _prepare_plot(self): for coord, r0, r1, x_label, y_label in [ ('Z', 0, 1, self.xlabel, self.ylabel), ]: self.ax[coord].set_title(f'{self.Titulo}') if self.Range is not None: self.ax[coord].set_xlim(self.Range[r0,:]) self.ax[coord].set_ylim(self.Range[r1,:]) self.ax[coord].set_xlabel(f'{x_label}') self.ax[coord].set_ylabel(f'{y_label}') self.ax[coord].grid()","title":"Trajectory"},{"location":"trajectory/#trajectory","text":"class phaseportrait.trajectories. trajectory ( dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg ) Parent class for trajectories. Represents trajectories given a dF function with N args. Class inheriting must have the following methods: def _prepare_plot(self): ... Prepares the plots: axis titles, graph title, grid, etc. def _plot_lines(self, val, val_init): ... Plots a line of points given in a tuple of positions val and an initial position val_init , both N-dimensional. def _scatter_start_point(self, val_init): ... Marks starting position val_init (N-dimensional) in the several plots created. def _scatter_trajectory(self, val, color, cmap): ... Plots with points val (N-dimensional list) according to color (N-dimensional) with cmap color map.","title":"trajectory"},{"location":"trajectory/#example-from-trajectories2d","text":"def _plot_lines(self, val, val_init): self.ax['Z'].plot(val[0,1:], val[1,1:], label=f\"({','.join(tuple(map(str, val_init)))})\") def _scatter_start_point(self, val_init): self.ax['Z'].scatter(val_init[0], val_init[1], s=self.size+1, c=[0]) def _scatter_trajectory(self, val, color, cmap): self.ax['Z'].scatter(val[0,:], val[1,:], s=self.size, c=color, cmap=cmap) def _prepare_plot(self): for coord, r0, r1, x_label, y_label in [ ('Z', 0, 1, self.xlabel, self.ylabel), ]: self.ax[coord].set_title(f'{self.Titulo}') if self.Range is not None: self.ax[coord].set_xlim(self.Range[r0,:]) self.ax[coord].set_ylim(self.Range[r1,:]) self.ax[coord].set_xlabel(f'{x_label}') self.ax[coord].set_ylabel(f'{y_label}') self.ax[coord].grid()","title":"Example (from Trajectories2D):"},{"location":"trajectory2d/","text":"Trajectory2D class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Computes a trajectory on a 2D system given a dF consisting of 2 args. Attributes Methods dF initial_position dF_args thermalize Range add_slider values plot velocity compute_trajectory initial_conditions rungekutta_time_independent runge_kutta_step runge_kutta_freq n_points Title xlabel ylabel fig ax sliders lines thermalization color Attributes dF ( dF function) - computes the derivatives of given coordinates. dF_args (dict) - dictionary with parameters for dF function. Range (Optional[list, float]) - see defining a 2D range . lines =False (bool) - representing with lines instead of points. color (str) - if 't' passed, trajectories are colored depending on time. It doesn't work with lines=True . In other case, it paints dependong on velocities with the color scheme given. termalization =0 (int) - number of steps taken before trajectory is saved. size =0.5 (float) - point size in the plot. numba =False (bool) - compiles dF using numba. n_points (int) - number of points in the plot. runge_kutta_spet (float) - time step in 4th order runge-kutta algorithm. runge_kutta_freq (int) - number of points computed between saved positions. Title (str) - title of the plot. Default value is 'Trajectory' . xlabel (str) - x axis label in the plot. Default value is 'X' . ylabel (str) - y axis label in the plot. Default value is 'Y' . mark_start_point (bool) - marks staring position with a bigger point size. Methods Trajectory2D .initial_position Trajectory2D . initial_position (* position ) Parameter position must be a 2 element list or ndarray. Trajectory2D .thermalize Trajectory2D . thermalize (* position ) Parameter position is optional. If it is not introduced, a random number between 0 and 1 will be taken for each coordinate. Trajectory2D .add_slider Trajectory2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Trajectory2D .plot Trajectory2D . plot (*, color=None) Takes as arguments class attributes. Color scheme can be changed introducing kwarg color . A list with accepted values can be found here . Trajectory2D .compute_trajectory Trajectory2D . compute_trajectory ( initial_values ) Given an initial posotion by initial_values (containing 3 coordinates), the method returns a tuple with two lists: positions and difference between following positions. Returns n_points points. Trajectory2D .rungekutta_time_independent Trajectory2D . rungekutta_time_independent ( initial_values ) Generator that given initial_values , returns the next point. Defining Range: A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Trajectory2d"},{"location":"trajectory2d/#trajectory2d","text":"class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Computes a trajectory on a 2D system given a dF consisting of 2 args. Attributes Methods dF initial_position dF_args thermalize Range add_slider values plot velocity compute_trajectory initial_conditions rungekutta_time_independent runge_kutta_step runge_kutta_freq n_points Title xlabel ylabel fig ax sliders lines thermalization color","title":"Trajectory2D"},{"location":"trajectory2d/#attributes","text":"dF ( dF function) - computes the derivatives of given coordinates. dF_args (dict) - dictionary with parameters for dF function. Range (Optional[list, float]) - see defining a 2D range . lines =False (bool) - representing with lines instead of points. color (str) - if 't' passed, trajectories are colored depending on time. It doesn't work with lines=True . In other case, it paints dependong on velocities with the color scheme given. termalization =0 (int) - number of steps taken before trajectory is saved. size =0.5 (float) - point size in the plot. numba =False (bool) - compiles dF using numba. n_points (int) - number of points in the plot. runge_kutta_spet (float) - time step in 4th order runge-kutta algorithm. runge_kutta_freq (int) - number of points computed between saved positions. Title (str) - title of the plot. Default value is 'Trajectory' . xlabel (str) - x axis label in the plot. Default value is 'X' . ylabel (str) - y axis label in the plot. Default value is 'Y' . mark_start_point (bool) - marks staring position with a bigger point size.","title":"Attributes"},{"location":"trajectory2d/#methods","text":"","title":"Methods"},{"location":"trajectory2d/#trajectory2dinitial_position","text":"Trajectory2D . initial_position (* position ) Parameter position must be a 2 element list or ndarray.","title":"Trajectory2D.initial_position"},{"location":"trajectory2d/#trajectory2dthermalize","text":"Trajectory2D . thermalize (* position ) Parameter position is optional. If it is not introduced, a random number between 0 and 1 will be taken for each coordinate.","title":"Trajectory2D.thermalize"},{"location":"trajectory2d/#trajectory2dadd_slider","text":"Trajectory2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time.","title":"Trajectory2D.add_slider"},{"location":"trajectory2d/#trajectory2dplot","text":"Trajectory2D . plot (*, color=None) Takes as arguments class attributes. Color scheme can be changed introducing kwarg color . A list with accepted values can be found here .","title":"Trajectory2D.plot"},{"location":"trajectory2d/#trajectory2dcompute_trajectory","text":"Trajectory2D . compute_trajectory ( initial_values ) Given an initial posotion by initial_values (containing 3 coordinates), the method returns a tuple with two lists: positions and difference between following positions. Returns n_points points.","title":"Trajectory2D.compute_trajectory"},{"location":"trajectory2d/#trajectory2drungekutta_time_independent","text":"Trajectory2D . rungekutta_time_independent ( initial_values ) Generator that given initial_values , returns the next point.","title":"Trajectory2D.rungekutta_time_independent"},{"location":"trajectory2d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Defining Range:"},{"location":"trajectory3d/","text":"Trajectory3D class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kwargs ) Inherits from parent class trajectory . Gives the option to represent 3D trajectories given a dF function with 3 args. Attributes Methods dF initial_position dF_args termalize Range add_slider values plot velocity compute_trajectory initial_conditions rungekutta_time_independent runge_kutta_step runge_kutta_freq n_points Title xlabel ylabel zlabel fig ax sliders lines termalization color Attributes dF ( dF function) - computes the derivatives of given coordinates. dF_args (dict) - dictionary with parameters for dF function. Range (Optional[list, float]) - see defining a 3D range . lines =False (bool) - representing with lines instead of points. color (str) - if 't' passed, trajectories are colored depending on time. It doesn't work with lines=True . In other case, it paints dependong on velocities with the color scheme given. termalization =0 (int) - number of steps taken before trajectory is saved. size =0.5 (float) - point size in the plot. numba =False (bool) - compiles dF using numba. n_points (int) - number of points in the plot. runge_kutta_spet (float) - time step in 4th order runge-kutta algorithm. runge_kutta_freq (int) - number of points computed between saved positions. Title (str) - title of the plot. Default value is 'Trajectory' . xlabel (str) - x axis label in the plot. Default value is 'X' . ylabel (str) - y axis label in the plot. Default value is 'Y' . zlabel (str) - z axis label in the plot. Default value is 'Z' . mark_start_point (bool) - marks staring position with a bigger point size. Methods Trajectory3D .initial_position Trajectory3D . initial_position (* position ) Parameter position must be a 3 element list or ndarray. Trajectory3D .termalize Trajectory3D . termalize (* position ) Parameter position is optional. If it is not introduced, a random number between 0 and 1 will be taken for each coordinate. Trajectory3D .add_slider Trajectory3D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Trajectory3D .plot Trajectory3D . plot (*, color=None) Takes as arguments class attributes. Color scheme can be changed introducing kwarg color . A list with accepted values can be found here . Trajectory3D .compute_trajectory Trajectory3D . compute_trajectory ( initial_values ) Given an initial posotion by initial_values (containing 3 coordinates), the method returns a tuple with two lists: positions and difference between following positions. Returns n_points points. Trajectory3D .rungekutta_time_independent Trajectory3D . rungekutta_time_independent ( initial_values ) Generator that given initial_values , returns the next point. Defining Range: A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]]","title":"Trajectory3d"},{"location":"trajectory3d/#trajectory3d","text":"class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kwargs ) Inherits from parent class trajectory . Gives the option to represent 3D trajectories given a dF function with 3 args. Attributes Methods dF initial_position dF_args termalize Range add_slider values plot velocity compute_trajectory initial_conditions rungekutta_time_independent runge_kutta_step runge_kutta_freq n_points Title xlabel ylabel zlabel fig ax sliders lines termalization color","title":"Trajectory3D"},{"location":"trajectory3d/#attributes","text":"dF ( dF function) - computes the derivatives of given coordinates. dF_args (dict) - dictionary with parameters for dF function. Range (Optional[list, float]) - see defining a 3D range . lines =False (bool) - representing with lines instead of points. color (str) - if 't' passed, trajectories are colored depending on time. It doesn't work with lines=True . In other case, it paints dependong on velocities with the color scheme given. termalization =0 (int) - number of steps taken before trajectory is saved. size =0.5 (float) - point size in the plot. numba =False (bool) - compiles dF using numba. n_points (int) - number of points in the plot. runge_kutta_spet (float) - time step in 4th order runge-kutta algorithm. runge_kutta_freq (int) - number of points computed between saved positions. Title (str) - title of the plot. Default value is 'Trajectory' . xlabel (str) - x axis label in the plot. Default value is 'X' . ylabel (str) - y axis label in the plot. Default value is 'Y' . zlabel (str) - z axis label in the plot. Default value is 'Z' . mark_start_point (bool) - marks staring position with a bigger point size.","title":"Attributes"},{"location":"trajectory3d/#methods","text":"","title":"Methods"},{"location":"trajectory3d/#trajectory3dinitial_position","text":"Trajectory3D . initial_position (* position ) Parameter position must be a 3 element list or ndarray.","title":"Trajectory3D.initial_position"},{"location":"trajectory3d/#trajectory3dtermalize","text":"Trajectory3D . termalize (* position ) Parameter position is optional. If it is not introduced, a random number between 0 and 1 will be taken for each coordinate.","title":"Trajectory3D.termalize"},{"location":"trajectory3d/#trajectory3dadd_slider","text":"Trajectory3D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time.","title":"Trajectory3D.add_slider"},{"location":"trajectory3d/#trajectory3dplot","text":"Trajectory3D . plot (*, color=None) Takes as arguments class attributes. Color scheme can be changed introducing kwarg color . A list with accepted values can be found here .","title":"Trajectory3D.plot"},{"location":"trajectory3d/#trajectory3dcompute_trajectory","text":"Trajectory3D . compute_trajectory ( initial_values ) Given an initial posotion by initial_values (containing 3 coordinates), the method returns a tuple with two lists: positions and difference between following positions. Returns n_points points.","title":"Trajectory3D.compute_trajectory"},{"location":"trajectory3d/#trajectory3drungekutta_time_independent","text":"Trajectory3D . rungekutta_time_independent ( initial_values ) Generator that given initial_values , returns the next point.","title":"Trajectory3D.rungekutta_time_independent"},{"location":"trajectory3d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]]","title":"Defining Range:"}]}